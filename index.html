<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
<title>SpinOut Prototype - Smooth Retro Digital</title>
<style>
  /* Font Import: Inter for a clean, modern digital look (MUST be first in the stylesheet) */
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
  
  /* --- Global & Fonts --- */
  :root {
    --bg-dark: #12121e; /* Deep dark blue-purple */
    --panel-bg: #1a1a2a; /* Slightly lighter panel */
    --accent-cyan: #00ffff; /* Primary Neon Cyan */
    --accent-red: #ff3366; /* Secondary Neon Magenta/Red */
    --text-color: #e0e0f0; /* Light text */
    --muted-color: #6a6a80; /* Muted gray-blue for labels */
    --log-bg: #0d0d15;
  }
  
  body {
    margin: 0;
    font-family: 'Inter', sans-serif;
    background: var(--bg-dark);
    color: var(--text-color);
    display: flex;
    min-height: 100vh;
    align-items: center;
    justify-content: center;
    font-size: 14px;
  }
  
  .wrap {
    width: 100%;
    max-width: 980px;
    display: grid;
    grid-template-columns: 1fr; 
    gap: 15px;
    padding: 10px; 
    box-sizing: border-box; 
  }

  /* --- Digital Panel Styling --- */
  .digital-panel {
    border: 1px solid var(--panel-bg);
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 10px rgba(0, 255, 255, 0.1);
    padding: 18px;
    background: var(--panel-bg);
    transition: all 0.3s ease;
  }

  .stage {
    position: relative;
    overflow: hidden;
    padding: 18px;
    background: #000000; /* Pure black stage for contrast */
    border: 1px solid var(--accent-cyan);
    border-radius: 12px;
  }
  
  canvas {
    width: 100%;
    height: 360px;
    display: block;
    background: #0d0d15; /* Dark canvas background */
    border: 2px solid var(--muted-color);
    box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.4); /* Neon glow */
    border-radius: 6px;
  }

  /* Scanlines for CRT effect - only over the canvas */
  .scanlines::before {
    content: '';
    position: absolute;
    top: 20px; left: 20px; right: 20px; bottom: 106px; 
    pointer-events: none;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.4),
      rgba(0, 0, 0, 0.6) 1px,
      transparent 2px,
      transparent 3px
    );
    opacity: 0.6;
    border-radius: 6px;
  }
  
  .panel {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .row { display: flex; gap: 10px; align-items: center; }
  
  /* --- Input Styling --- */
  input[type=number], input[type=text] {
    width: 100px;
    padding: 8px 10px;
    border: 1px solid var(--muted-color);
    background: #000000;
    color: var(--accent-cyan);
    font-family: monospace;
    font-size: 14px;
    border-radius: 4px;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.6);
    min-height: 30px;
  }
  
  /* --- Button Styling (Sleek Digital Look) --- */
  button {
    padding: 10px 15px;
    border: none;
    font-family: 'Inter', sans-serif;
    font-weight: 700;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.1s ease;
    text-transform: uppercase;
    font-size: 12px;
    letter-spacing: 1px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }
  
  button#placeBetBtn { 
    background: #005577; 
    color: var(--accent-cyan); 
    border: 1px solid var(--accent-cyan);
    box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
  }
  button#placeBetBtn:hover { background: #006688; }

  button#cashoutBtn { 
    background: var(--accent-cyan); 
    color: #000000; 
    font-weight: 900;
    box-shadow: 0 0 12px var(--accent-cyan);
  }
  button#cashoutBtn:hover { opacity: 0.9; }

  button.secondary { 
    background: #333345; 
    color: var(--text-color); 
    border: 1px solid var(--muted-color);
  }
  button.secondary:hover { background: #444456; }
  
  button:disabled { 
    opacity: 0.4; 
    cursor: default; 
    box-shadow: none;
    background: #333345 !important;
  }

  /* --- Display Elements --- */
  .big-mult {
    font-size: 48px; 
    font-weight: 900;
    letter-spacing: -1px;
    color: var(--accent-cyan); 
    text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
    transition: color 0.1s;
  }
  
  .crashed-text {
    color: var(--accent-red);
    text-shadow: 0 0 15px rgba(255, 51, 102, 0.8);
  }

  .countdown-text {
      font-size: 36px; 
      font-weight: 900;
      color: #ffaa00; /* Amber/Orange for countdown */
      text-shadow: 0 0 10px rgba(255, 170, 0, 0.8);
  }
  /* Heat visuals removed - hide heat bar and its inner fill */
  .heat,
  .heat > i {
    display: none !important;
    visibility: hidden !important;
    width: 0 !important;
    height: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    box-shadow: none !important;
  }

  .log {
    font-size: 12px;
    color: var(--text-color);
    height: 100px;
    overflow-y: scroll;
    padding: 8px;
    background: var(--log-bg);
    border: 1px solid var(--muted-color);
    font-family: monospace;
    line-height: 1.4;
    border-radius: 4px;
    box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
  }
  
  .meta, label {
    font-size: 11px;
    color: var(--muted-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .small {
    font-size: 12px;
    color: var(--muted-color);
    font-family: monospace;
  }
  
  .badge {
    background: #333345;
    padding: 6px 10px;
    border: 1px solid var(--muted-color);
    color: var(--accent-cyan);
    font-weight: 700;
    font-size: 12px;
    border-radius: 4px;
  }
  
  .verify {
    font-size: 11px;
    background: var(--log-bg);
    padding: 8px;
    border: 1px dashed var(--muted-color);
    color: var(--accent-cyan);
    font-family: monospace;
    word-break: break-all;
    border-radius: 4px;
  }
  
  .verify input {
      background: none;
      border: none;
      padding: 0;
      width: 140px;
      color: var(--accent-cyan);
  }
  
  /* Styling for Racers Container */
  #racersContainer {
      max-height: 200px; 
      overflow-y: auto; 
      padding: 5px; 
      background: var(--log-bg); 
      border-radius: 4px;
      border: 1px solid var(--muted-color);
      box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
      line-height: 1.5;
  }

  /* --- Leaderboard & Rules styles (insert into <style>) --- */
  .leaderboard {
    font-size: 13px;
    color: var(--text-color);
    background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.25));
    border: 1px solid var(--muted-color);
    padding: 8px;
    border-radius: 6px;
    line-height: 1.4;
    height: 140px;
    overflow-y: auto;
    font-family: monospace;
  }
  .leaderboard .row{ display:flex; justify-content:space-between; gap:10px; padding:4px 0; border-bottom: 1px dashed #222233; }
  .leaderboard .you{ color:var(--accent-cyan); font-weight:800; }

  .rules-panel {
    margin-top: 12px;
    height: 220px;
    background: linear-gradient(180deg,#05050a 0%, #070716 100%);
    border: 1px solid rgba(0,255,255,0.18);
    box-shadow: inset 0 0 40px rgba(0,255,255,0.02), 0 6px 18px rgba(0,0,0,0.6);
    border-radius: 6px;
    padding: 12px;
    color: #7ef2ea;
    font-family: "Courier New", Courier, monospace;
    font-size: 13px;
    line-height: 1.4;
    overflow-y: auto;
    letter-spacing: 0.6px;
  }
  .rules-panel .rules-title { color: rgba(0,255,255,0.95); font-weight:900; margin-bottom:8px; font-size:14px; }
  .rules-panel ol{ margin:0; padding-left:18px; }
  .rules-panel li{ margin:6px 0; }
  .rules-panel .muted{ color: var(--muted-color); font-size:12px; display:block; margin-top:4px; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage scanlines digital-panel">
      <canvas id="gameCanvas" width="640" height="360"></canvas>
      
      <div style="display:flex;justify-content:space-between;align-items:flex-end;margin-top:20px;padding-bottom:12px;border-bottom:1px solid #333345;">
        <div>
          <div class="big-mult" id="multiplierDisplay">1.00x</div>
          <div class="small">ROUND: <span id="roundId" style="color:var(--accent-cyan)">0</span> &nbsp; STATE: <span id="state" style="color:var(--accent-red)">IDLE</span></div>
        </div>
        <div style="text-align:right">
          <div class="small">BALANCE: <strong id="balance" style="color:#ffffff;font-size:16px;">R1000.00</strong></div>
          <div class="small">CURRENT BET: <strong id="currentBet" style="color:#ffffff;font-size:16px;">R0</strong></div>
        </div>
      </div>
      
      <div style="display:flex;gap:15px;margin-top:15px;align-items:center">
        <div style="flex:1">
          <div class="heat" title="Police Heat Meter"><i id="heatFill"></i></div>
        </div>
        <div style="width:200px;text-align:right; font-size: 14px;" id="statusText" class="crashed-text"></div>
      </div>

      <div class="rules-panel" id="rulesPanel" aria-live="polite" role="region" aria-label="Game rules">
        <div class="rules-title">SPIN'A — CORE RULES</div>
        <ol>
          <li><strong>Place Bets</strong>: Wager between R1 - R50,000. Up to two simultaneous bets per round (double-down).</li>
          <li><strong>Race Begins</strong>: After the countdown the car accelerates and the multiplier starts at 1.00×.</li>
          <li><strong>Multiplier Rises</strong>: Decide when to <em>Cash Out</em> while multiplier climbs.</li>
          <li><strong>Crash (Police Arrive)</strong>: A random event ends the round — if you haven't cashed out you lose.</li>
          <li><strong>Win</strong>: Cashed out in time → Payout = Bet × Multiplier at cashout.</li>
          <li><strong>Loss</strong>: Failure to cash out before crash → bet is lost.</li>
          <li><strong>New Round</strong>: Short intermission (5–8s) then next race begins.</li>
        </ol>
        <div style="height:8px"></div>
        <div class="rules-title">KEY FEATURES</div>
        <ol start="8">
          <li><strong>Auto Cashout</strong>: Pre-set a target (e.g. 1.5×, 2×, 3×) and the system will cash you out automatically.</li>
          <li><strong>Double Down Drift</strong>: Once per round, before 5×, you may double your bet. If you crash you lose both bets; if you cash out both pay at final multiplier.</li>
          <li class="muted">Tip: Nitro increases speed (visual & multiplier); sirens indicate high crash probability.</li>
        </ol>
      </div>
    </div>

    <div class="panel digital-panel">
      <!-- Controls -->
      <div class="row">
        <label>Bet Amount (R)</label>
        <input type="number" id="betInput" min="1" value="10"/>
        <button id="placeBetBtn">Lock Bet</button>
      </div>

      <div class="row">
        <!-- Start Race button repurposed to indicate Auto Start / Countdown -->
        <button id="startRoundBtn" disabled style="background:#555577 !important; color: #ccc;">Starting next race...</button>
        <button id="cashoutBtn" disabled>Cash Out</button>
        <button id="doubleDownBtn" class="secondary">Double Down</button>
      </div>

      <!-- Auto Cashout Row with Toggle -->
      <div class="row" style="border-top: 1px solid #333345; padding-top: 10px; justify-content: space-between;">
        <!-- Auto Cashout Controls -->
        <div style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="autoCashoutToggle" checked style="width: 16px; height: 16px; accent-color: var(--accent-cyan);"/>
          <label for="autoCashoutToggle">Auto Cashout (x)</label>
          <input id="autoInput" type="number" min="1.01" value="2.00" style="width:70px"/>
        </div>

        <!-- Background music controls -->
        <div style="display:flex; align-items:center; gap:8px;">
          <button id="musicToggle" class="secondary" title="Toggle background music">Music: Off</button>
          <input id="musicVol" type="range" min="0" max="1" step="0.01" value="0.25" style="width:90px"/>
        </div>
       
        <!-- Badges -->
        <div style="display: flex; gap: 10px;">
          <div class="badge">Nitro: <span id="nitroChance">10%</span></div>
          <div class="badge">RTP: <span id="avgRTP">97%</span></div>
        </div>
      </div>
      
      <!-- This Round's Racers Section -->
      <div style="flex-direction: column; align-items: stretch; border-top: 1px solid #333345; padding-top: 10px;">
        <div class="meta" style="margin-bottom: 5px;">This Round's Racers (<span id="activeRacersCount">0</span>/20)</div>
        <div id="racersContainer">
          <!-- Mock player status will be injected here -->
        </div>
      </div>

      <!-- Leaderboard (tracks profit/loss per participant during the demo) -->
      <div style="flex-direction: column; align-items: stretch; border-top: 1px solid #333345; padding-top: 10px; margin-top:10px;">
        <div class="meta">Leaderboard</div>
        <div class="leaderboard" id="leaderboard" aria-live="polite" role="status"></div>
      </div>

      <div class="row" style="flex-direction: column; align-items: stretch;">
        <div class="meta">Session Log</div>
        <div class="log" id="log"></div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;flex-direction:column">
        <div class="meta">Provably Fair Verification (Demo)</div>
        <div class="verify">HASH: <span id="serverSeedHash"></span></div>
        <div class="verify" style="color:var(--text-color)">CLIENT SEED: <input id="clientSeedInput" value="player123" type="text" style="width:100px; font-size: 11px;"/></div>
        <div class="verify">NONCE: <span id="nonce">0</span></div>
        <button id="revealSeedBtn" class="secondary" style="margin-top: 10px;">Reveal Server Seed</button>
      </div>

    </div>
  </div>

<script>
/*
  SpinOut Prototype - Smooth Retro Digital (Multi-Round Ready with Mock Players)
*/

(() => {
  // MOCK PLAYER NAMES (expanded)
  const MOCK_PLAYERS = [
    'Ayola','Molefe','Tino','Rorisang','Gcina','Vuyo','Tembalethu','Akhona','Lathitha','Ayesha',
    'Georgie','Luvo','Mocca','Sis Bulie','Ta Malbi','Buhle','Coco','Midnight','Lucky','Tiny'
  ];

  // ---------- Utilities ----------
  function $(id){return document.getElementById(id)}
  function log(txt){ const el=$('log'); el.innerHTML = (new Date()).toLocaleTimeString() + ' · ' + txt + '<br/>' + el.innerHTML; }
  function formatR(x){ return 'R' + x.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}) }

  //  TTS Utility Function 
  function speakLine(text, rate=1.1, pitch=1.0) {
    try {
      const utter = new SpeechSynthesisUtterance(text);
      utter.rate = rate;
      utter.pitch = pitch;
      utter.volume = 0.9;
      speechSynthesis.cancel(); // stop previous overlapping speech
      speechSynthesis.speak(utter);
    } catch (e) {
      console.warn("TTS unavailable:", e);
    }
  }
  // sha256 helper using SubtleCrypto: returns hex
  async function sha256Hex(str){
    const enc = new TextEncoder();
    const data = enc.encode(str);
    const hash = await crypto.subtle.digest('SHA-256', data);
    const arr = Array.from(new Uint8Array(hash));
    return arr.map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  // get first 13 hex chars -> 52 bits randomness (safe integer)
  function randomFromHash(hashHex){
    const first13 = hashHex.slice(0,13); // 13 hex chars = 52 bits
    const num = parseInt(first13, 16); // <= 2^52-1 safe
    const denom = Math.pow(2,52);
    return num / denom; // in [0,1)
  }

  // map random [0,1) to a multiplier using the 2% house edge formula (P_target = 0.98)
  // Map random [0,1) to multiplier in range [1.00, 5000.00].
  // Use an exponential mapping to heavily skew results toward low multipliers
  // but still allow very large outcomes up to 5000x.
function multiplierFromRandom(r) {
  const MAX_M = 5000;
  const rand = Math.random();

  // Probability tiers
  if (rand < 0.60) {
    // 60% of the time, crash early between 1.00x – 1.99x
    return +(1 + Math.random() * 0.99).toFixed(2);
  }
  else if (rand < 0.96) {
    // 36% of the time, moderate runs between 2x – 9.99x
    const mid = 2 + Math.pow(Math.random(), 1.8) * 8; // bias lower in range
    return +mid.toFixed(2);
  }
  else {
    // 4% of the time, big wins between 10x – 5000x (rare)
    const high = 10 + Math.pow(Math.random(), 3.5) * (MAX_M - 10);
    return +Math.min(MAX_M, high).toFixed(2);
}


return Math.max(1.00, Math.min(MAX_M, floored));
  } 

  // ---------- Provably fair seeds (demo) ----------
  let serverSeed = null;
  let serverSeedHash = '';
  let nonce = 0;

  async function newServerSeed(){
    serverSeed = [...Array(40)].map(()=>Math.floor(Math.random()*16).toString(16)).join('');
    serverSeedHash = await sha256Hex(serverSeed);
    $('serverSeedHash').textContent = serverSeedHash.slice(0, 16) + '...'; // Truncate for display
    $('nonce').textContent = nonce;
    log('New server seed generated (hash updated).');
  }

  async function computeRoundHash(clientSeed, nonceLocal){
    const data = serverSeed + ':' + clientSeed + ':' + nonceLocal;
    const h = await sha256Hex(data);
    return h;
  }

  // ---------- Game State ----------
  const state = {
    balance: 10000.00,
    currentBet: 0,
    currentBetActive: false,
    doubleDownActive: false,
    round: 0,
    maxMockRounds: 1000,
    running: false,
    multiplier: 1,
    targetMultiplier: null,
    clientSeed: $('clientSeedInput').value || 'player123',
    nitroActive: false,
    nitroChance: 0.10, // 10%
    isAutoCashoutEnabled: true, 
    racersStatus: [], // Array to hold mock player round data
    roundStartDelay: 10000, // 10 seconds
    autoStartTimeoutId: null,
    countdownIntervalId: null,
    countdownRemaining: 0,
  };

  // UI refs
  const canvas = $('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  
  // Animation loop variables
  let animFrameId = null;
  let lastTimestamp = 0;
  let startTime = 0;

  // --- DIGITAL PALETTE ---
  const PALETTE = {
    BG: '#0d0d15',     
    ROAD: '#222233',   
    CAR: '#00ffff',    // Cyan Car
    NEON_CYAN: '#00ffff', 
    FLAME: '#ff66aa',  // Pink/Magenta Flame
    POLICE_RED: '#ff3366', // Magenta
    POLICE_BLUE: '#00ccff', // Light Cyan
    WHITE: '#ffffff'
  };

  // ---------- Mock Player Logic (DYNAMIC TARGETING) ----------

  function getTargetByRiskProfile(){
    const HIGH_GREEDY_CHANCE = 0.08; // increase chance for rare huge targets (was 3%)
    const roll = Math.random();

    // Rare greedy behaviour: pick a very large target up to 5,000x (skewed)
    if (Math.random() < HIGH_GREEDY_CHANCE) {
      // exponential mapping for dramatic but rare targets
      const raw = Math.pow(5000, Math.random()); // 1..5000
      return parseFloat(Math.max(3, raw).toFixed(2));
    }

    let min, max;
    if (roll < 0.35) { // 35% Low Risk (Turtles)
        min = 1.05; max = 1.30;
    } else if (roll < 0.85) { // 50% Medium Risk (Averages)
        min = 1.30; max = 3.00;
    } else { // 15% High Risk (Ninjas/Whales)
        min = 3.00; max = 15.00; 
    }

    // Prefer values near the low end of the range but with a heavy tail
    const target = min + (max - min) * (1 - Math.pow(Math.random(), 3));
    return parseFloat(target.toFixed(2));
  }

  function generateMockBets() {
  const currentRacers = [];
  const playersInRound = MOCK_PLAYERS.filter((_, i) => i < 5 || Math.random() > 0.5);

  const userProfit = playersLedger['You'].profit || 0;
  const aggressionFactor = Math.min(1.5, Math.max(0.5, 1 + userProfit / 50000)); 
  // userProfit > 0 makes mocks more aggressive

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  playersInRound.forEach(name => {
    if (Math.random() < 0.95) {
      const ledger = playersLedger[name] || { balance: 1000000 };
      // Aggressive scaling based on user's success
      let bet = + (randInt(250, 5000) * aggressionFactor).toFixed(2);

      // adjust targets to be riskier (larger multipliers)
      const baseTarget = 1.5 + Math.random() * 10 * aggressionFactor;
      const target = Math.min(20, baseTarget);

      currentRacers.push({
        name,
        bet,
        target: parseFloat(target.toFixed(2)),
        cashedOut: false,
        winnings: 0,
        statusText: 'RACING'
      });
    }
  });

  // Sort so aggressive mocks appear higher
  currentRacers.sort((a, b) => b.bet - a.bet);
  return currentRacers;
   }

  function updateRacersUI(){
    const container = $('racersContainer');
    container.innerHTML = '';
    
    // Sort by status: CASHOUT first, then RACING, then CRASHED.
    state.racersStatus.sort((a, b) => {
        if (a.statusText === 'CASHOUT' && b.statusText !== 'CASHOUT') return -1;
        if (a.statusText !== 'CASHOUT' && b.statusText === 'CASHOUT') return 1;
        if (a.statusText === 'CRASHED' && b.statusText !== 'CRASHED') return 1;
        if (a.statusText !== 'CRASHED' && b.statusText === 'CRASHED') return -1;
        // Sort by cashout/target multiplier for those still racing/cashing out
        return a.target - b.target;
    });

    state.racersStatus.forEach(r => {
      let color = '#fff';
      if (r.statusText === 'CASHOUT') color = 'var(--accent-cyan)';
      if (r.statusText === 'CRASHED') color = 'var(--accent-red)';
      
      const statusText = r.cashedOut 
        ? `Won ${formatR(r.winnings)} @ x${r.target.toFixed(2)}`
        : (r.statusText === 'CRASHED' ? 'CRASHED' : 'Target x' + r.target.toFixed(2));
      
      const racerDiv = document.createElement('div');
      racerDiv.style.cssText = `display:flex; justify-content:space-between; padding: 4px 0; border-bottom: 1px dotted #2a2a40; font-size: 12px;`;
      racerDiv.innerHTML = `
        <span style="color:${color}; font-weight:700; width: 80px;">${r.name}</span>
        <span style="width: 50px; text-align:right;">R${r.bet}</span>
        <span style="width: 150px; text-align:right; color: ${color};">${statusText}</span>
      `;
      container.appendChild(racerDiv);
    });

    $('activeRacersCount').textContent = state.racersStatus.length;
  }


  // ---------- Visual assets (smoother, cleaner lines) ----------
  function drawScene(mult, stateVisual, shakeOffset = {x:0,y:0,rot:0}){
    stateVisual = stateVisual || {};
    // assume ctx, W, H exist
    ctx.save();
    ctx.translate(shakeOffset.x || 0, shakeOffset.y || 0);
    if (shakeOffset.rot) ctx.rotate(shakeOffset.rot * Math.PI / 180);
    const t = performance.now();

    // clear
    ctx.fillStyle = PALETTE.BG || '#0d0d15';
    ctx.fillRect(0,0,W,H);

    // horizon gradient
    const g = ctx.createLinearGradient(0, H*0.12, 0, H*0.5);
    g.addColorStop(0, '#071018'); g.addColorStop(1, '#051018');
    ctx.fillStyle = g; ctx.fillRect(0, H*0.08, W, H*0.5);

    // road bands
    ctx.fillStyle = '#08161b';
    ctx.fillRect(0, H*0.6, W, H*0.25);
    ctx.fillStyle = '#0b2a2f';
    ctx.fillRect(0, H*0.65, W, H*0.18);

    // city lines (parallax)
    ctx.strokeStyle = 'rgba(0,255,255,0.03)'; ctx.lineWidth = 1;
    for(let i=0;i<20;i++){
      const x = (i/W) * W + ((t/80) % 40);
      ctx.beginPath(); ctx.moveTo((i*60 + (t/12)%60) % W, H*0.48); ctx.lineTo((i*60 + (t/9)%90) % W, H*0.58); ctx.stroke();
    }

    // dotted lane markers
    ctx.fillStyle = PALETTE.NEON_CYAN || '#00ffff';
    const dotY = H*0.88;
    for(let i=12;i<W-12;i+=14){
      ctx.fillRect(i, dotY, 4, 6);
    }

    // car icon (simple)
    ctx.fillStyle = PALETTE.CAR || '#00a3a3';
    ctx.beginPath();
    ctx.moveTo(W*0.5 - 14, H*0.78);
    ctx.lineTo(W*0.5 + 14, H*0.78);
    ctx.lineTo(W*0.5 + 8, H*0.74);
    ctx.lineTo(W*0.5 - 8, H*0.74);
    ctx.closePath();
    ctx.fill();

    // nitro flames layered
    if(state.nitroActive){
      const pulse = 0.6 + 0.4 * Math.sin(t / 60);
      const intensity = Math.min(1, Math.max(0.4, (mult / 8))) * pulse;
      for(let layer=0; layer<3; layer++){
        const radius = 28 + layer * 8;
        const alpha = 0.18 * (1 - layer*0.22) * intensity;
        ctx.beginPath();
        const cx = W*0.5; const cy = H*0.76;
        const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, radius);
        grad.addColorStop(0, `rgba(255,150,200,${alpha})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);
        ctx.fillStyle = grad;
        ctx.arc(cx, cy, radius, Math.PI, 2*Math.PI);
        ctx.fill();
      }
    }

    // police flash overlay
    if(stateVisual.policeFlash){
      ctx.fillStyle = stateVisual.flashColor || 'rgba(255,51,102,0.9)';
      ctx.globalAlpha = 0.22;
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1.0;
    }

    ctx.restore();
  }

  // renderFrame replacement (shake + HUD strobe)
  function renderFrame(mult, policeFlash, flashColor){
    let shake = {x:0,y:0,rot:0};
    if(state.running && mult > 5.0){
      const intensity = Math.min(1, (mult - 5) / 15);
      const maxShake = 10 * intensity;
      const maxRot = 0.9 * intensity;
      shake.x = (Math.random()*2 - 1) * maxShake;
      shake.y = (Math.random()*2 - 1) * (maxShake * 0.6);
      shake.rot = (Math.random()*2 - 1) * maxRot;
      const multEl = document.getElementById('multiplierDisplay');
      if(multEl){
        if(Math.floor(performance.now() / 80) % 2 === 0){
          multEl.style.textShadow = '0 0 30px rgba(255,255,255,0.9), 0 0 18px rgba(255,170,0,0.8)';
        } else {
          multEl.style.textShadow = '0 0 20px rgba(0,255,255,0.9)';
        }
      }
    } else {
      const multEl = document.getElementById('multiplierDisplay'); if(multEl) multEl.style.textShadow = '';
    }

    // apply CSS transform for shake
    const canvasEl = document.getElementById('gameCanvas');
    if(canvasEl){
      canvasEl.style.transform = `translate(${shake.x}px, ${shake.y}px) rotate(${shake.rot}deg)`;
      canvasEl.style.willChange = 'transform';
    }

    drawScene(mult, {policeFlash, flashColor}, shake);

    // update multiplier text
    const multDisplay = document.getElementById('multiplierDisplay');
    if(multDisplay){
      multDisplay.classList.remove('crashed-text', 'countdown-text');
      if(state.running){
        if(mult === 0) { multDisplay.textContent = 'CRASH!'; multDisplay.classList.add('crashed-text'); }
        else multDisplay.textContent = (mult || 1).toFixed(2) + 'x';
      } else if(state.countdownRemaining > 0) {
        multDisplay.textContent = state.countdownRemaining + 's';
        multDisplay.classList.add('countdown-text');
      } else {
        multDisplay.textContent = '1.00x';
      }
    }
  }

  // Ledger constants & helpers
  const START_BANKROLL = 10000;
  const YOU_START_BANKROLL = 10000;
  const playersLedger = {};

  function initPlayersLedger(){
    (typeof MOCK_PLAYERS !== 'undefined' ? MOCK_PLAYERS : []).forEach(name => {
      playersLedger[name] = {
        name,
        startBalance: START_BANKROLL,
        balance: START_BANKROLL,
        roundsParticipated:0, roundsWon:0, roundsLost:0, totalBet:0, totalWon:0
      };
    });
    playersLedger['You'] = {
      name: 'You',
      startBalance: YOU_START_BANKROLL,
      balance: YOU_START_BANKROLL,
      roundsParticipated:0, roundsWon:0, roundsLost:0, totalBet:0, totalWon:0
    };
    updateLeaderboardUI();
  }

  function updateLeaderboardUI() {
  const el = document.getElementById('leaderboard');
  if (!el) return;

  // Recalculate all player profits before displaying
  Object.values(playersLedger).forEach(p => {
    p.profit = +(p.balance - p.startBalance).toFixed(2);
  });

  const arr = Object.values(playersLedger)
    .map(p => ({
      ...p,
      participated: p.roundsParticipated || 0,
      winRate: p.roundsParticipated
        ? ((p.roundsWon / p.roundsParticipated) * 100).toFixed(1)
        : '0.0'
    }))
    .sort((a, b) => b.profit - a.profit);
    
  el.innerHTML = `
    <div style="display:flex; font-weight:700; justify-content:space-between; padding:6px 4px; border-bottom:1px solid #222233; color:var(--muted-color); font-size:12px;">
      <div style="width:140px;">Player</div>
      <div style="width:90px; text-align:right;">Total Bets</div>
      <div style="width:80px; text-align:right;">Win %</div>
      <div style="width:110px; text-align:right;">Balance</div>
      <div style="width:90px; text-align:right;">Profit</div>
    </div>`;

  arr.forEach(p => {
    const profitColor = p.profit >= 0 ? '#8cffc6' : '#ff99aa';
    const profitSign = p.profit >= 0 ? '+' : '';
    el.innerHTML += `
      <div class="row${p.name === 'You' ? ' you' : ''}">
        <div style="width:140px;"><strong>${p.name}</strong></div>
        <div style="width:90px; text-align:right;">R${p.totalBet.toFixed(2)}</div>
        <div style="width:80px; text-align:right;">${p.winRate}%</div>
        <div style="width:110px; text-align:right;">R${p.balance.toFixed(2)}</div>
        <div style="width:90px; text-align:right; color:${profitColor}">${profitSign}R${Math.abs(p.profit).toFixed(2)}</div>
      </div>`;
  });
   }

  // drawScene replacement (guard stateVisual)
  function drawScene(mult, stateVisual, shakeOffset = {x:0,y:0,rot:0}){
    stateVisual = stateVisual || {};
    // assume ctx, W, H exist
    ctx.save();
    ctx.translate(shakeOffset.x || 0, shakeOffset.y || 0);
    if (shakeOffset.rot) ctx.rotate(shakeOffset.rot * Math.PI / 180);
    const t = performance.now();

    // clear
    ctx.fillStyle = PALETTE.BG || '#0d0d15';
    ctx.fillRect(0,0,W,H);

    // horizon gradient
    const g = ctx.createLinearGradient(0, H*0.12, 0, H*0.5);
    g.addColorStop(0, '#071018'); g.addColorStop(1, '#051018');
    ctx.fillStyle = g; ctx.fillRect(0, H*0.08, W, H*0.5);

    // road bands
    ctx.fillStyle = '#08161b';
    ctx.fillRect(0, H*0.6, W, H*0.25);
    ctx.fillStyle = '#0b2a2f';
    ctx.fillRect(0, H*0.65, W, H*0.18);

    // city lines (parallax)
    ctx.strokeStyle = 'rgba(0,255,255,0.03)'; ctx.lineWidth = 1;
    for(let i=0;i<20;i++){
      const x = (i/W) * W + ((t/80) % 40);
      ctx.beginPath(); ctx.moveTo((i*60 + (t/12)%60) % W, H*0.48); ctx.lineTo((i*60 + (t/9)%90) % W, H*0.58); ctx.stroke();
    }

    // dotted lane markers
    ctx.fillStyle = PALETTE.NEON_CYAN || '#00ffff';
    const dotY = H*0.88;
    for(let i=12;i<W-12;i+=14){
      ctx.fillRect(i, dotY, 4, 6);
    }

    // car icon (simple)
    ctx.fillStyle = PALETTE.CAR || '#00a3a3';
    ctx.beginPath();
    ctx.moveTo(W*0.5 - 14, H*0.78);
    ctx.lineTo(W*0.5 + 14, H*0.78);
    ctx.lineTo(W*0.5 + 8, H*0.74);
    ctx.lineTo(W*0.5 - 8, H*0.74);
    ctx.closePath();
    ctx.fill();

    // nitro flames layered
    if(state.nitroActive){
      const pulse = 0.6 + 0.4 * Math.sin(t / 60);
      const intensity = Math.min(1, Math.max(0.4, (mult / 8))) * pulse;
      for(let layer=0; layer<3; layer++){
        const radius = 28 + layer * 8;
        const alpha = 0.18 * (1 - layer*0.22) * intensity;
        ctx.beginPath();
        const cx = W*0.5; const cy = H*0.76;
        const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, radius);
        grad.addColorStop(0, `rgba(255,150,200,${alpha})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);
        ctx.fillStyle = grad;
        ctx.arc(cx, cy, radius, Math.PI, 2*Math.PI);
        ctx.fill();
      }
    } /*

    // police flash overlay
    if(stateVisual.policeFlash){
      ctx.fillStyle = stateVisual.flashColor || 'rgba(255,51,102,0.9)';
      ctx.globalAlpha = 0.22;
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1.0;
    } */

    ctx.restore();
  }

  // cashout: pay player immediately but keep round running (replace existing cashout)
  async function cashout(mode='manual', roundHash, crashMultiplier) {
  if (!state.running || !state.currentBetActive) return;
   if (state.playerCashedOut) return;
    state.playerCashedOut = true;

    const betAmount = state.currentBet;
    const cashoutMult = state.multiplier;
    const payout = Math.floor((betAmount * cashoutMult) * 100) / 100;

    state.currentBetActive = false;
    state.playerCashedOut = true;
    state.playerCashout = { mult: cashoutMult, payout };

    // credit immediately
    state.balance = Math.round((state.balance + payout) * 100) / 100;
    document.getElementById('balance').textContent = formatR(state.balance);

    // update ledger for You
    const you = playersLedger['You'];
    if(you){
      you.balance = Math.round((you.balance + payout) * 100) / 100;
      you.totalWon += payout;
      you.roundsWon++;
    }

    // clear bet UI and disable controls
    state.currentBet = 0;
    document.getElementById('currentBet').textContent = formatR(0);
    document.getElementById('cashoutBtn').disabled = true;
    document.getElementById('placeBetBtn').disabled = true;
    document.getElementById('doubleDownBtn').disabled = true;

    // add/update "You" in racersStatus
    let youEntry = state.racersStatus.find(r => r.name === 'You');
    if(!youEntry){
      state.racersStatus.unshift({ name:'You', bet: betAmount, target: cashoutMult, cashedOut:true, winnings:payout, statusText:'CASHOUT' });
    } else {
      youEntry.cashedOut = true; youEntry.winnings = payout; youEntry.statusText = 'CASHOUT'; youEntry.target = cashoutMult; youEntry.bet = betAmount;
    }
    updateRacersUI();
    updateLeaderboardUI();
    log(`${mode==='auto'?'Auto-cashed out':'Cashed out'} @ ${cashoutMult.toFixed(2)}x. Won ${formatR(payout)}.`);

    // Intentionally do NOT stop animation; round continues for mocks
  }

  // finalizeRound: avoid double-pay & update ledgers (replace existing finalizeRound)
  function finalizeRound(won, payout, hashHex, crashMultiplier){
    document.getElementById('cashoutBtn').disabled = true;
    document.getElementById('placeBetBtn').disabled = false;
    document.getElementById('doubleDownBtn').disabled = false;

    document.getElementById('state').textContent = 'IDLE';
    document.getElementById('state').style.color = 'var(--accent-red)';

    if (state.round > 0) {
      if (won && state.currentBetActive) {
        state.balance = Math.round((state.balance + payout) * 100) / 100;
        document.getElementById('balance').textContent = formatR(state.balance);
      } else {
        document.getElementById('balance').textContent = formatR(state.balance);
      }
    }

    // mark mock players who didn't cash out as crashed and update ledger
    state.racersStatus.forEach(r => {
      if(!r.cashedOut){
        r.statusText = 'CRASHED';
        r.winnings = 0;
        const p = playersLedger[r.name];
        if(p) p.roundsLost++;
      }
    });
    updateRacersUI();

    if (state.round > 0) {
       if(!won){
         if(state.playerCashedOut){
           const pc = state.playerCashout || {};
           log(`Round ${state.round} CRASHED at ${crashMultiplier.toFixed(2)}x. You cashed out earlier @ ${pc.mult ? pc.mult.toFixed(2)+'x' : 'N/A'} — Won ${pc.payout ? formatR(pc.payout) : 'R0'}.`);
         } else {
           log(`Round ${state.round} CRASHED at ${crashMultiplier.toFixed(2)}x. Bet Lost: R${state.currentBetActive ? state.currentBet : 0}`);
         }
       } else {
         log(`CASHOUT SUCCESS! Won ${formatR(payout)} at ${state.multiplier.toFixed(2)}x (Crash was at ${crashMultiplier.toFixed(2)}x)`);
       }
     }
 
    if (!state.doubleDownActive) {
      state.currentBet = 0;
      state.currentBetActive = false;
    }
    state.doubleDownActive = false;

    // clear player cashout tracking for next round
    state.playerCashedOut = false;
    state.playerCashout = null;

    document.getElementById('currentBet').textContent = formatR(state.currentBet);
    document.getElementById('heatFill').style.width = '0%';
    document.getElementById('statusText').textContent = '';

    updateLeaderboardUI();
    // extra safety: ensure leaderboard reflects final ledger state after all updates
    setTimeout(() => updateLeaderboardUI(), 100);
 
     // stop/ramp down engine audio if any (ensure stopEngineAudio exists)
    if(typeof stopEngineAudio === 'function') stopEngineAudio();

    // AUTO-START NEXT ROUND WITH COUNTDOWN (copied/adapted from spin_a_ver3.html)
    if(state.round >= state.maxMockRounds) {
        log(`DEMO COMPLETE: Reached maximum ${state.maxMockRounds} mock rounds.`);
        document.getElementById('startRoundBtn').textContent = 'DEMO COMPLETE';
        document.getElementById('startRoundBtn').disabled = true;
        renderFrame(0, false);
        return;
    }

    if(state.autoStartTimeoutId) clearTimeout(state.autoStartTimeoutId);
    if(state.countdownIntervalId) clearInterval(state.countdownIntervalId);

    document.getElementById('startRoundBtn').disabled = true;

    // Ensure player can still lock bets / interact while countdown runs
    const placeBtn = document.getElementById('placeBetBtn');
    const betInput = document.getElementById('betInput');
    const doubleBtn = document.getElementById('doubleDownBtn');
    if(placeBtn) placeBtn.disabled = false;
    if(betInput) betInput.disabled = false;
    if(doubleBtn) doubleBtn.disabled = false;

     state.countdownRemaining = state.roundStartDelay / 1000;

     // updateCountdown updates the visible countdown once per second
     const updateCountdown = () => {
         const btn = document.getElementById('startRoundBtn');
         if (!btn) return;
         if (state.countdownRemaining > 0) {
             btn.textContent = `NEXT RACE in ${state.countdownRemaining}s (Round ${state.round + 1})`;
             state.countdownRemaining--;
         } else {
             btn.textContent = 'Starting next race...';
             if (state.countdownIntervalId) {
                 clearInterval(state.countdownIntervalId);
                 state.countdownIntervalId = null;
             }
         }
     };
     state.countdownIntervalId = setInterval(updateCountdown, 1000);

    state.autoStartTimeoutId = setTimeout(async () => {
        clearInterval(state.countdownIntervalId);

        const hasSufficientFunds = state.currentBet > 0 && state.balance >= state.currentBet;
        const playerIsReady = state.currentBetActive && hasSufficientFunds;

        if(playerIsReady || !state.currentBetActive){
            if(playerIsReady){
                state.balance = Math.round((state.balance - state.currentBet) * 100) / 100;
                document.getElementById('balance').textContent = formatR(state.balance);
                const you = playersLedger['You'];
                if(you){
                  you.balance = Math.round((you.balance - state.currentBet) * 100) / 100;
                  you.totalBet += state.currentBet;
                  you.roundsParticipated++;
                }
            }
            await startRound();
        } else {
            log('Race skipped. Replenish your balance or lock a bet to join the next race!');
            document.getElementById('startRoundBtn').textContent = 'WAITING - LOCK BET';
            document.getElementById('startRoundBtn').disabled = false;
        }
    }, state.roundStartDelay);
  }

  async function startRoundImpl(){
  if(state.running) return;
  state.round = Math.max(0, state.round) + 1;
  state.running = true;
  state.multiplier = 1;
  state.playerCashedOut = false;
  state.playerCashout = null;
  document.getElementById('roundId').textContent = state.round;
  document.getElementById('state').textContent = 'RUNNING';
  document.getElementById('state').style.color = 'var(--accent-cyan)';
  document.getElementById('startRoundBtn').disabled = true;
  // enable cashout button only if player has a locked bet for this round
  const cashBtnEl = document.getElementById('cashoutBtn');
  if (cashBtnEl) cashBtnEl.disabled = !state.currentBetActive;
  document.getElementById('placeBetBtn').disabled = true;
  document.getElementById('doubleDownBtn').disabled = true;

  // prepare racers (include "You" entry if you locked a bet)
  state.racersStatus = generateMockBets();

  // Deduct mock players' bets at round start and record participation so leaderboard profit/loss & win% are accurate
  state.racersStatus.forEach(r => {
    const p = playersLedger[r.name];
    if(p){
      p.balance = Math.round((p.balance - r.bet) * 100) / 100;
      p.totalBet = (p.totalBet || 0) + r.bet;
      p.roundsParticipated = (p.roundsParticipated || 0) + 1;
    }
  });

  if(state.currentBetActive){
    // ensure 'You' is represented early in the list
    const youIdx = state.racersStatus.findIndex(r => r.name === 'You');
    if(youIdx === -1){
      state.racersStatus.unshift({ name:'You', bet: state.currentBet, target: parseFloat($('autoInput').value)||2.00, cashedOut:false, winnings:0, statusText:'RACING' });
    } else {
      state.racersStatus[youIdx].bet = state.currentBet;
      state.racersStatus[youIdx].target = parseFloat($('autoInput').value)||2.00;
      state.racersStatus[youIdx].cashedOut = false;
      state.racersStatus[youIdx].statusText = 'RACING';
    }
  }
  updateRacersUI();
  updateLeaderboardUI();

  // Determine deterministic crash multiplier from seeds
  const roundNonce = nonce;
  const roundHash = await computeRoundHash(state.clientSeed || $('clientSeedInput').value || 'player123', roundNonce);
  nonce++;
  $('nonce').textContent = nonce;
  const rnd = randomFromHash(roundHash);
  const crashMult = multiplierFromRandom(rnd) || 1.00;
  state.targetMultiplier = crashMult;

  // Choose a run duration so the multiplier grows visually
  // Adaptive duration: longer for rounds with larger crashMult
  const MAX_M_FOR_CURVE = 5000;
  const logMax = Math.log10(MAX_M_FOR_CURVE);
  const logCrash = Math.log10(Math.max(1, crashMult));
  const crashNormalized = Math.min(1, Math.max(0, logCrash / logMax));
  // base durations (ms) — tuned for feel; high crashNormalized increases duration
  const BASE_DURATION = 444;            // minimum base
  const ADDED_DURATION = 4444;          // extra length available
  // add a small random variance so rounds don't all feel identical
  let durationMs = Math.round(BASE_DURATION + ADDED_DURATION * (0.25 + 0.75 * crashNormalized) * (0.8 + Math.random() * 1.4));
  // Slow down high-mult rounds: scale duration so rounds destined for large multipliers run slower.
  // This scales duration from 1x (low crash) up to ~10x (highest crashes) — effectively making high-number climbs ~1/10th speed.
  const slowdownFactor = 1 + 9 * crashNormalized; // range: 1 .. 10
  durationMs = Math.round(durationMs * slowdownFactor);
  let startTs = null;
 
   startEngineAudio();
 
   // per-frame simulator
   function step(ts){
     if(!startTs) startTs = ts;
     const elapsed = ts - startTs;
     const ratio = Math.min(1, elapsed / durationMs);
 
    // Adaptive easing curve:
    // - use an exponent that depends on the crash target (log scale)
    // - low crash -> exponent < 1 (faster early growth)
    // - high crash -> exponent > 1 (slower early growth, big acceleration late)
    const minExp = 0.6;   // aggressive/faster early
    const maxExp = 3.0;   // slow-start, late rush for big wins
    const expo = minExp + (maxExp - minExp) * (Math.log10(Math.max(1, crashMult)) / Math.log10(MAX_M_FOR_CURVE));
    const easedRatio = Math.pow(Math.max(0, ratio), expo);
    // use easedRatio to drive an exponential curve that still reaches crashMult at easedRatio==1
    state.multiplier = Math.max(1, Math.exp(Math.log(crashMult) * easedRatio));
    
    // update mock racers: those whose target <= current multiplier will auto cashout
    state.racersStatus.forEach(r => {
      if(!r.cashedOut && r.statusText === 'RACING' && r.target <= state.multiplier){
        r.cashedOut = true;
        r.winnings = Math.floor((r.bet * state.multiplier) * 100) / 100;
        r.statusText = 'CASHOUT';
        const p = playersLedger[r.name];
        if(p){
          p.balance = Math.round((p.balance + r.winnings) * 100) / 100;
          p.totalWon += r.winnings;
          p.roundsWon++;
        }
      }
    });
    updateRacersUI();
    // update leaderboard so profit/loss display stays in sync when mocks cash out
    updateLeaderboardUI();

    // handle player's auto cashout (if enabled)
    if (state.currentBetActive && state.isAutoCashoutEnabled && !state.playerCashedOut) {
      const target = parseFloat($('autoInput').value);
    if (target && state.multiplier >= target) {
    cashout('auto', roundHash, crashMult);
      }
    }

    // update visual + audio
    renderFrame(state.multiplier, state.multiplier > crashMult * 0.8, state.multiplier > crashMult * 0.9 ? PALETTE.POLICE_RED : null);
    updateEngineSound(state.multiplier, state.nitroActive, state.running);

    if(ratio < 1 && state.running){
      animFrameId = requestAnimationFrame(step);
      return;
    }

    // crash happens when ratio >= 1 (round ends)
    state.running = false;
    // if player already cashed out, we keep crashMult for log; otherwise apply crash
    const playerWon = state.playerCashedOut === true;
    // mark remaining racers as crashed (they didn't cash)
    state.racersStatus.forEach(r => {
      if(!r.cashedOut){
        r.statusText = 'CRASHED';
        r.winnings = 0;
        const p = playersLedger[r.name];
        if(p) p.roundsLost++;
      }
    });
    updateRacersUI();

    // show crash visually (set multiplier to 0 to trigger CRASH display in renderFrame)
    state.multiplier = 0;
    renderFrame(0, true, PALETTE.POLICE_RED);
    stopEngineAudio();

    // finalize round (if player cashed out, finalize will log the win accordingly)
    // payout param expects numeric payout when player won; pass 0 otherwise
    const payout = playerWon && state.playerCashout ? state.playerCashout.payout || 0 : 0;
    finalizeRound(playerWon, payout, roundHash, crashMult);
  }

  // start loop
  animFrameId = requestAnimationFrame(step);
}

// expose as a candidate the shim looks for, and make it the default startRound
window.startRoundImpl = startRoundImpl;
window.startRound = startRoundImpl;

// Minimal engine audio helpers (safe no-op if AudioContext blocked)
let engineAudioContext = null;
function startEngineAudio(){
  try{
    if(engineAudioContext) return;
    engineAudioContext = new (window.AudioContext || window.webkitAudioContext)();
    const osc = engineAudioContext.createOscillator();
    const gain = engineAudioContext.createGain();
    osc.type = 'sawtooth';
    osc.frequency.value = 60;
    gain.gain.value = 0.00001; // effectively silent until ramped
    osc.connect(gain);
    gain.connect(engineAudioContext.destination);
    osc.start();
    // store refs on state for updates
    state._engineCtx = engineAudioContext;
    state._engineOsc = osc;
    state._engineGain = gain;
  }catch(e){
    engineAudioContext = null;
    state._engineCtx = state._engineOsc = state._engineGain = null;
  }
}

function updateEngineSound(mult = 1, nitro = false, running = false){
  const ctx = state._engineCtx;
  const osc = state._engineOsc;
  const gain = state._engineGain;
  if(!ctx || !osc || !gain) return;
  try{
    const freq = 60 + Math.min(1500, Math.max(0, (mult - 1) * 80));
    osc.frequency.setTargetAtTime(freq, ctx.currentTime, 0.05);
    const baseVol = running ? Math.min(0.12, 0.02 + Math.log10(Math.max(1, mult)) * 0.03) : 0.00001;
    const vol = baseVol + (nitro ? 0.04 : 0);
    gain.gain.setTargetAtTime(vol, ctx.currentTime, 0.08);
  }catch(e){}
}

function stopEngineAudio(){
  const ctx = state._engineCtx;
  const osc = state._engineOsc;
  const gain = state._engineGain;
  if(!ctx || !osc || !gain) return;
  try{
    gain.gain.setTargetAtTime(0, ctx.currentTime, 0.05);
    setTimeout(() => {
      try{ osc.stop(); osc.disconnect(); gain.disconnect(); }catch(e){}
      state._engineCtx = state._engineOsc = state._engineGain = null;
      engineAudioContext = null;
    }, 150);
  }catch(e){}
}

// ---------- Background music (simple loop + UI) ----------
const BG_MUSIC_SRC = 'assets/bg_music.mp3'; // place file in assets/ or change URL
const bgMusic = new Audio(BG_MUSIC_SRC);
bgMusic.loop = true;
const DEFAULT_MUSIC_VOL = 0.25;
bgMusic.volume = DEFAULT_MUSIC_VOL;
let musicStarted = false;
let savedMusicVolume = DEFAULT_MUSIC_VOL;

// Charge/engine layer: BMW charge sound (looped). Place your file at assets/bmw_charge.mp3
const CHARGE_SRC = 'assets/bmw_charge.mp3';
const chargeSound = new Audio(CHARGE_SRC);
chargeSound.loop = true;
chargeSound.volume = 0.18;
let chargeStarted = false;

function ensureMusicStarted(){
  if(musicStarted) return;
  // attempt to start; will succeed only on a user gesture
  bgMusic.play().then(()=> {
    musicStarted = true;
    savedMusicVolume = bgMusic.volume;
    const b = $('musicToggle'); if(b) b.textContent = 'Music: On';
    log('Background music started.');
  }).catch(()=> {
    // blocked until user interaction; UI button will try again
    log('Background music blocked by browser — click Music: Off to enable.');
  });
}

function toggleMusic(){
  const btn = $('musicToggle');
  if(!musicStarted){
    ensureMusicStarted();
    return;
  }
  if(bgMusic.paused){
    bgMusic.play(); if(btn) btn.textContent = 'Music: On'; log('Background music resumed.');
  } else {
    bgMusic.pause(); if(btn) btn.textContent = 'Music: Off'; log('Background music paused.');
  }
}

function setMusicVolume(v){
  const vol = Math.max(0, Math.min(1, Number(v)));
  bgMusic.volume = vol;
  savedMusicVolume = vol;
}

// Duck music during engine sounds (smoothly)
function duckMusic(enable){
  if(!musicStarted) return;
  if(enable){
    // lower to 22% of saved volume
    bgMusic.volume = Math.max(0, savedMusicVolume * 0.22);
  } else {
    bgMusic.volume = savedMusicVolume;
  }
}

// hook the ducking into engine audio lifecycle
const originalStartEngineAudio = typeof startEngineAudio === 'function' ? startEngineAudio : null;
const originalStopEngineAudio = typeof stopEngineAudio === 'function' ? stopEngineAudio : null;
if(originalStartEngineAudio){
  startEngineAudio = function(...args){
    originalStartEngineAudio.apply(this, args);
    // duck music a little when engine starts
    duckMusic(true);
    // try to start BMW charge sound (may be blocked until user gesture)
    try { chargeSound.play().then(()=>{ chargeStarted = true; }).catch(()=>{}); } catch(e){}
  };
}
if(originalStopEngineAudio){
  stopEngineAudio = function(...args){
    originalStopEngineAudio.apply(this, args);
    // restore music after engine stops
    duckMusic(false);
    try { chargeSound.pause(); chargeSound.currentTime = 0; chargeStarted = false; } catch(e){}
  };
}

// wire music UI (setupUIHandlers will also call ensureMusicStarted on first meaningful gesture)
document.addEventListener('DOMContentLoaded', () => {
  const btn = $('musicToggle');
  const vol = $('musicVol');
  if(btn) btn.addEventListener('click', toggleMusic);
  if(vol){
    vol.addEventListener('input', (e) => setMusicVolume(e.target.value));
    // set initial slider value to match default
    vol.value = DEFAULT_MUSIC_VOL;
  }
});

// Enhance engine audio control: modify updateEngineSound to also drive chargeSound pitch/vol
const _origUpdateEngineSound = typeof updateEngineSound === 'function' ? updateEngineSound : null;
updateEngineSound = function(mult = 1, nitro = false, running = false){
  if(_origUpdateEngineSound) _origUpdateEngineSound.apply(this, [mult, nitro, running]);
  try{
    if(chargeSound){
      // map multiplier to a pleasant playbackRate using log scale
      const logMult = Math.log10(Math.max(1, mult));
      const rate = 0.8 + Math.min(4.0, logMult); // ~0.8..4.0
      chargeSound.playbackRate = rate;
      // volume slightly depends on running and multiplier (kept modest)
      const volBase = Math.min(0.9, 0.06 + Math.max(0, logMult) * 0.03);
      chargeSound.volume = running ? Math.max(0.02, volBase) : Math.max(0.01, volBase * 0.5);
      // ensure BMW charge plays while numbers are going up: run && mult > 1
      if(running && mult > 1){
        if(!chargeStarted){
          chargeSound.play().then(()=>{ chargeStarted = true; }).catch(()=>{});
        } else if(chargeSound.paused){
          // resume if paused
          chargeSound.play().catch(()=>{});
        }
      } else {
        // pause/reset when not actively climbing (idle or after crash)
        try { if(!chargeSound.paused){ chargeSound.pause(); chargeSound.currentTime = 0; } } catch(e){}
        chargeStarted = false;
      }
    }
  }catch(e){}
};

// --- UI handlers: enable Lock Bet, Cash Out, Double Down, manual Start ---
function setupUIHandlers(){
  const placeBtn = $('placeBetBtn');
  const cashBtn = $('cashoutBtn');
  const doubleBtn = $('doubleDownBtn');
  const betInput = $('betInput');
  const startBtn = $('startRoundBtn');

  // Auto cashout toggle wiring: read initial state and keep state in sync with UI
  const autoToggle = $('autoCashoutToggle');
  state.isAutoCashoutEnabled = !!(autoToggle && autoToggle.checked);
  if(autoToggle){
    autoToggle.addEventListener('change', (e) => {
      state.isAutoCashoutEnabled = !!e.target.checked;
      log('Auto Cashout ' + (state.isAutoCashoutEnabled ? 'enabled' : 'disabled') + '.');
    });
  }
  
  // Toggle lock/unlock bet before the round starts
  placeBtn.addEventListener('click', () => {
    if(state.currentBetActive){
      // unlock
      state.currentBetActive = false;
      // if the round hasn't started, return bet to display (actual bankroll was not deducted yet)
      state.currentBet = 0;
      placeBtn.textContent = 'Lock Bet';
      betInput.disabled = false;
      $('currentBet').textContent = formatR(0);
      log('Bet unlocked.');
    } else {
      const val = Number(betInput.value) || 0;
      if(val <= 0){
        log('Enter a valid bet amount.');
        return;
      }
      if(val > state.balance){
        log('Insufficient balance to lock that bet.');
        return;
      }
      // enforce a reasonable max (UI uses R500 in rules)
      const MAX_BET = 50000;
      if(val > MAX_BET){
        log(`Max bet is R${MAX_BET}.`);
        return;
      }
      state.currentBet = Math.round(val * 100) / 100;
      state.currentBetActive = true;
      placeBtn.textContent = 'Bet Locked';
      betInput.disabled = true;
      $('currentBet').textContent = formatR(state.currentBet);
      log(`Bet locked: ${formatR(state.currentBet)}. Ready for next race.`);
    }
  });

  // Cash out (only meaningful when round is running)
  cashBtn.addEventListener('click', () => {
    if(!state.running){
      log('Cannot cash out — race is not running.');
      return;
    }
    if(!state.currentBetActive && !state.playerCashedOut){
      log('No active bet to cash out.');
      return;
    }
    // call existing cashout helper (it will credit immediately)
    cashout('manual');
  });

  // Double down before round starts (simple implementation)
  doubleBtn.addEventListener('click', () => {
    if(state.doubleDownActive){
      log('Double-down already used this round.');
      return;
    }
    if(!state.currentBetActive){
      log('Lock a bet first to double down.');
      return;
    }
    if(state.running){
      log('Double-down not allowed once the race has started.');
      return;
    }
    // ensure player has funds to match current bet
    if(state.balance < state.currentBet){
      log('Insufficient balance to double down.');
      return;
    }
    state.currentBet = Math.round((state.currentBet * 2) * 100) / 100;
    state.doubleDownActive = true;
    $('currentBet').textContent = formatR(state.currentBet);
    placeBtn.textContent = 'Bet Locked (Double)';
    log(`Double-down accepted. New bet: ${formatR(state.currentBet)}.`);
  });

  // Manual start (if allowed)
  startBtn.addEventListener('click', async () => {
    if(state.running) return;
    // if player has a locked bet and enough balance, deduct immediately (same behavior as auto start)
    if(state.currentBetActive && state.balance >= state.currentBet){
      state.balance = Math.round((state.balance - state.currentBet) * 100) / 100;
      $('balance').textContent = formatR(state.balance);
      const you = playersLedger['You'];
      if(you){
        you.balance = Math.round((you.balance - state.currentBet) * 100) / 100;
        you.totalBet += state.currentBet;
        you.roundsParticipated++;
      }
    }
    // call startRound (alias to startRoundImpl)
    await startRound();
  });
}
// Startup: init players ledger and welcome message (insert into initial IIFE after newServerSeed and renderFrame)
  (async ()=>{

    await newServerSeed();
    $('balance').textContent = formatR(state.balance);
    $('nitroChance').textContent = (state.nitroChance*100).toFixed(0) + '%';
    renderFrame(1, false);
    initPlayersLedger();

    // wire up UI handlers so player can lock bets & interact during countdown
    setupUIHandlers();

    const welcomeMsg = `Welcome to Spin'A! Starting the first round countdown (Demo limit: ${state.maxMockRounds} rounds).`;
    log(welcomeMsg);
    document.getElementById('statusText').textContent = welcomeMsg;
    const multDisplay = document.getElementById('multiplierDisplay');
    if(multDisplay){ multDisplay.textContent = welcomeMsg; multDisplay.classList.add('countdown-text'); }
    
    // Play the welcome message visually for 5s, then start the demo auto-countdown (1000 rounds)
    setTimeout(()=>{ 
      if(multDisplay){ multDisplay.classList.remove('countdown-text'); renderFrame(1,false); }
      document.getElementById('statusText').textContent = '';

      // kick off the auto-start countdown by using finalizeRound like version 3 does
     
      state.round = -1;
      finalizeRound(false, 0, 'INITIAL_HASH', 1.00);
   
    }, 5000);
  })();

})();
</script>
</body>
</html>


